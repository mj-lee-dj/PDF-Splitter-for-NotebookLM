// 2단계: 페이지별 구조 분석 (개선됨)
      const analyzePageStructures = async (pdf, totalPages, tocItems) => {
        const structures = [];
        // 샘플링 간격을 줄여 더 촘촘하게 검사 (50페이지 이하는 전수 조사)
        const sampleStep = totalPages <= 50 ? 1 : Math.max(1, Math.floor(totalPages / 50));

        for (let pageNum = 1; pageNum <= totalPages; pageNum += sampleStep) {
          try {
            const page = await pdf.getPage(pageNum);
            const content = await page.getTextContent();
            const items = content.items;
            
            if (items.length === 0) continue;

            // 페이지 내 가장 큰 폰트 크기 찾기
            const maxFontSize = Math.max(...items.map(i => i.transform[0] || 0));
            // 평균 폰트 크기 (본문 크기 추정)
            const avgFontSize = items.reduce((sum, i) => sum + (i.transform[0] || 0), 0) / items.length;

            // 좌표 기준 정렬 (위 -> 아래, 왼쪽 -> 오른쪽)
            // PDF 좌표계는 y가 아래에서 위로 증가하므로 내림차순 정렬이 상단임
            items.sort((a, b) => {
              if (Math.abs(b.transform[5] - a.transform[5]) > 5) { // y좌표 차이가 5 이상이면 줄바꿈으로 간주
                 return b.transform[5] - a.transform[5];
              }
              return a.transform[4] - b.transform[4]; // 같은 줄이면 x좌표 오름차순
            });

            // 상단 영역(페이지 높이의 상위 20% 이내)에 있는 텍스트만 필터링
            // 정확한 page height를 모르므로, 첫 번째 아이템의 y좌표를 기준으로 상단 200 unit 이내만 검사
            const topY = items[0].transform[5];
            const topSectionItems = items.filter(i => topY - i.transform[5] < 150);

            // 제목 후보 찾기: 상단 영역에 있으면서, 폰트가 가장 큰 것 (최대 크기의 90% 이상)
            const titleCandidates = topSectionItems.filter(i => (i.transform[0] || 0) >= maxFontSize * 0.9);

            // 제목 후보들을 합치되, 너무 멀리 떨어진 건 제외
            let topText = "";
            if (titleCandidates.length > 0) {
                // 가장 큰 글자들만 순서대로 결합
                topText = titleCandidates.map(i => i.str).join(' ').trim();
            }

            // 텍스트 길이 체크 (너무 긴 문장은 제목이 아닐 확률 높음)
            const textLength = topText.replace(/\s+/g, '').length;
            
            // 소주제 표지 감지: 텍스트가 적고 폰트가 압도적으로 클 때
            const isTitlePage = items.length < 50 && maxFontSize > avgFontSize * 1.5;

            // 상단 제목 감지 조건 강화
            // 1. 폰트가 본문보다 확연히 커야 함 (1.2배 이상)
            // 2. 텍스트 길이가 적당해야 함 (2글자 이상 40글자 이하) - 긴 문장 제외
            // 3. 숫자로 시작하거나, 단원명 패턴이어야 함
            const isValidTitle = topText.length >= 2 && topText.length < 40;
            const isBigFont = maxFontSize > avgFontSize * 1.2;
            
            const hasTopTitle = isValidTitle && isBigFont && (
                /^(제?\s*\d+|Chapter|Part|Lesson|Unit|\d+\.)/i.test(topText) || // 번호로 시작
                isTitlePage // 혹은 표지 스타일
            );

            // 목차 항목과 매칭 (정확도 향상을 위해 텍스트 유사도 체크 강화)
            const tocMatch = tocItems.find(item => 
              Math.abs(item.page - pageNum) <= 1 &&
              (topText.replace(/\s/g,'').includes(item.title.replace(/\s/g,'')) || 
               item.title.replace(/\s/g,'').includes(topText.replace(/\s/g,'')))
            );

            structures.push({
              page: pageNum,
              isTitlePage,
              hasTopTitle,
              topText: topText, // 이제 엉뚱한 문장이 붙지 않은 깔끔한 제목이 들어갑니다
              tocMatch: tocMatch || null
            });

          } catch (error) {
            console.error(`페이지 ${pageNum} 분석 오류:`, error);
          }
        }

        return structures;
      };
